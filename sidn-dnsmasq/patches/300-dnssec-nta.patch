diff --git a/src/cache.c b/src/cache.c
index 178d654..564baa8 100644
--- a/src/cache.c
+++ b/src/cache.c
@@ -1028,6 +1028,62 @@ int read_hostsfile(char *filename, unsigned int index, int cache_size, struct cr
   
   return name_count;
 }
+
+
+#ifdef HAVE_DNSSEC
+struct nta_list *add_nta(const char *nta, struct nta_list *prev_nta) {
+  struct nta_list *ntas;
+  ntas = malloc(sizeof(struct nta_list));
+  ntas->next = NULL;
+  ntas->nta = malloc(strlen(nta) + 1);
+  strcpy(ntas->nta, nta);
+  ntas->next = prev_nta;
+  return ntas;
+}
+
+void free_nta_list(struct nta_list *ntas) {
+  if (ntas) {
+    struct nta_list *next = ntas->next;
+    free(ntas->nta);
+    free(ntas);
+    free_nta_list(next);
+  }
+}
+
+void print_nta_list(struct nta_list *ntas) {
+  if (ntas && ntas->nta) {
+    printf("[XX] NTA: %s\n", ntas->nta);
+    print_nta_list(ntas->next);
+  }
+}
+
+int read_nta_file(const char* filename, struct nta_list **ntas) {
+  FILE *f = fopen(filename, "r");
+  int nta_count = 0, lineno = 0;
+  char token[1024];
+  memset(token, 0, 1024);
+  int atnl;
+
+  if (!f)
+    {
+      my_syslog(LOG_ERR, _("failed to load ntas from %s: %s"), filename, strerror(errno));
+      return nta_count;
+    }
+
+  while ((atnl = gettok(f, token)) != EOF)
+    {
+      lineno++;
+      if (strlen(token) > 0)
+        {
+          *ntas = add_nta(token, *ntas);
+          nta_count++;
+        }
+    }
+
+  my_syslog(LOG_INFO, "Read %d ntas from %s", nta_count, filename);
+  return nta_count;
+}
+#endif
 	    
 void cache_reload(void)
 {
@@ -1099,6 +1155,10 @@ void cache_reload(void)
 	cache->uid = ds->class;
 	cache_hash(cache);
       }
+
+  if (daemon->nta_file) {
+    read_nta_file(daemon->nta_file, &daemon->ntas);
+  }
 #endif
   
   /* borrow the packet buffer for a temporary by-address hash */
diff --git a/src/dnsmasq.c b/src/dnsmasq.c
index 81254f6..900e711 100644
--- a/src/dnsmasq.c
+++ b/src/dnsmasq.c
@@ -30,6 +30,9 @@ static void sig_handler(int sig);
 static void async_event(int pipe, time_t now);
 static void fatal_event(struct event_desc *ev, char *msg);
 static int read_event(int fd, struct event_desc *evp, char **msg);
+#ifdef HAVE_DNSSEC
+static void poll_nta_file(int force, int do_reload);
+#endif
 static void poll_resolv(int force, int do_reload, time_t now);
 
 int main (int argc, char **argv)
@@ -728,6 +731,10 @@ int main (int argc, char **argv)
       
       if (option_bool(OPT_DNSSEC_TIME))
 	my_syslog(LOG_INFO, _("DNSSEC signature timestamps not checked until first cache reload"));
+
+    daemon->ntas = NULL;
+    daemon->nta_mtime = 0;
+    daemon->last_nta_poll = 0;
       
       if (rc == 1)
 	my_syslog(LOG_INFO, _("DNSSEC signature timestamps not checked until system time valid"));
@@ -987,6 +994,18 @@ int main (int argc, char **argv)
 
       if (poll_check(piperead, POLLIN))
 	async_event(piperead, now);
+
+#ifdef HAVE_DNSSEC
+      /* Check for changes to nta file once per second max. */
+      /* Don't go silent for long periods if the clock goes backwards. */
+      if (daemon->last_nta_poll == 0 || 
+	  difftime(now, daemon->last_nta_poll) > 1.0 || 
+	  difftime(now, daemon->last_nta_poll) < -1.0)
+        {
+          poll_nta_file(0, daemon->last_nta_poll != 0);
+          daemon->last_nta_poll = now;
+        }
+#endif
       
 #ifdef HAVE_DBUS
       /* if we didn't create a DBus connection, retry now. */ 
@@ -1339,6 +1358,27 @@ static void async_event(int pipe, time_t now)
       }
 }
 
+#ifdef HAVE_DNSSEC
+static void poll_nta_file(int force, int do_reload)
+{
+    const char* nta_file = daemon->nta_file;
+
+    struct stat statbuf;
+
+    if (nta_file == NULL || stat(nta_file, &statbuf) == -1) {
+        return;
+    }
+    if (difftime(statbuf.st_mtime, daemon->nta_mtime) > 0.0 || force) {
+        if (do_reload) {
+            free_nta_list(daemon->ntas);
+            daemon->ntas = NULL;
+            read_nta_file(nta_file, &daemon->ntas);
+            daemon->nta_mtime = statbuf.st_mtime;
+        }
+    }
+}
+#endif
+
 static void poll_resolv(int force, int do_reload, time_t now)
 {
   struct resolvc *res, *latest;
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index cf1a782..4abd44b 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -603,6 +603,11 @@ struct hostsfile {
 #define HASH_SIZE sizeof(int)
 #endif
 
+struct nta_list {
+  struct nta_list *next;
+  char *nta;
+};
+
 struct frec {
   union mysockaddr source;
   struct all_addr dest;
@@ -995,7 +1000,11 @@ extern struct daemon {
   struct ds_config *ds;
   int back_to_the_future;
   char *timestamp_file;
+  struct nta_list *ntas;
+  time_t last_nta_poll;
+  time_t nta_mtime;
 #endif
+  char *nta_file;
 
   /* globally used stuff for DNS */
   char *packet; /* packet buffer */
@@ -1093,6 +1102,8 @@ void blockdata_report(void);
 struct blockdata *blockdata_alloc(char *data, size_t len);
 void *blockdata_retrieve(struct blockdata *block, size_t len, void *data);
 void blockdata_free(struct blockdata *blocks);
+void free_nta_list(struct nta_list *ntas);
+int read_nta_file(const char *filename, struct nta_list **ntas);
 #endif
 
 /* domain.c */
diff --git a/src/dnssec.c b/src/dnssec.c
index 4deda24..8b8706f 100644
--- a/src/dnssec.c
+++ b/src/dnssec.c
@@ -984,6 +984,11 @@ int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen, ch
   struct blockdata *key;
   struct all_addr a;
 
+  /* If this domain is mentioned in the NTA list, consider it insecure */
+  if (nta_list_contains(daemon->ntas, name)) {
+      return STAT_INSECURE;
+  }
+
   if (ntohs(header->qdcount) != 1 ||
       !extract_name(header, plen, &p, name, 1, 4))
     return STAT_BOGUS;
@@ -1000,6 +1005,7 @@ int dnssec_validate_by_ds(time_t now, struct dns_header *header, size_t plen, ch
       strcpy(keyname, name);
       return STAT_NEED_DS;
     }
+
   
   /* If we've cached that DS provably doesn't exist, result must be INSECURE */
   if (crecp->flags & F_NEG)
@@ -1804,6 +1810,17 @@ static int prove_non_existence_nsec3(struct dns_header *header, size_t plen, uns
   return STAT_SECURE;
 }
     
+int nta_list_contains(struct nta_list *ntas, const char* name) {
+  if (ntas && ntas->nta)
+    {
+      if (strcmp(ntas->nta, name) == 0)
+        return 1;
+      else
+        return nta_list_contains(ntas->next, name);
+    }
+  return 0;
+}
+
 /* Validate all the RRsets in the answer and authority sections of the reply (4035:3.2.3) */
 /* Returns are the same as validate_rrset, plus the class if the missing key is in *class */
 int dnssec_validate_reply(time_t now, struct dns_header *header, size_t plen, char *name, char *keyname, 
diff --git a/src/forward.c b/src/forward.c
index 2731b90..e49af33 100644
--- a/src/forward.c
+++ b/src/forward.c
@@ -421,8 +421,11 @@ static int forward_query(int udpfd, union mysockaddr *udpaddr,
 	  size_t new_plen = add_do_bit(header, plen, ((char *) header) + daemon->packet_buff_sz);
 	 
 	  /* For debugging, set Checking Disabled, otherwise, have the upstream check too,
-	     this allows it to select auth servers when one is returning bad data. */
-	  if (option_bool(OPT_DNSSEC_DEBUG))
+	     this allows it to select auth servers when one is returning bad data.
+         Additionally, set CD bit if we are looking at an NTA as well.
+       */
+      int is_nta = 1;
+	  if (option_bool(OPT_DNSSEC_DEBUG) || is_nta)
 	    header->hb4 |= HB4_CD;
 
 	  if (new_plen != plen)
diff --git a/src/option.c b/src/option.c
index ecc2619..afa597c 100644
--- a/src/option.c
+++ b/src/option.c
@@ -154,6 +154,7 @@ struct myoption {
 #define LOPT_HOST_INOTIFY  342
 #define LOPT_DNSSEC_STAMP  343
 #define LOPT_TFTP_NO_FAIL  344
+#define LOPT_DNSSEC_NTA_FILE 348
 
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -304,6 +305,7 @@ static const struct myoption opts[] =
     { "dnssec-check-unsigned", 0, 0, LOPT_DNSSEC_CHECK },
     { "dnssec-no-timecheck", 0, 0, LOPT_DNSSEC_TIME },
     { "dnssec-timestamp", 1, 0, LOPT_DNSSEC_STAMP },
+    { "dnssec-nta-file", 1, 0, LOPT_DNSSEC_NTA_FILE },
 #ifdef OPTION6_PREFIX_CLASS 
     { "dhcp-prefix-class", 1, 0, LOPT_PREF_CLSS },
 #endif
@@ -469,6 +471,7 @@ static struct {
   { LOPT_DNSSEC_CHECK, OPT_DNSSEC_NO_SIGN, NULL, gettext_noop("Ensure answers without DNSSEC are in unsigned zones."), NULL },
   { LOPT_DNSSEC_TIME, OPT_DNSSEC_TIME, NULL, gettext_noop("Don't check DNSSEC signature timestamps until first cache-reload"), NULL },
   { LOPT_DNSSEC_STAMP, ARG_ONE, "<path>", gettext_noop("Timestamp file to verify system clock for DNSSEC"), NULL },
+  { LOPT_DNSSEC_NTA_FILE, ARG_DUP, "<path>", gettext_noop("Read negative trust anchors from file"), NULL },
 #ifdef OPTION6_PREFIX_CLASS 
   { LOPT_PREF_CLSS, ARG_DUP, "set:tag,<class>", gettext_noop("Specify DHCPv6 prefix class"), NULL },
 #endif
@@ -3929,6 +3932,16 @@ static int one_opt(int option, char *arg, char *errstr, char *gen_err, int comma
 	
 	break;
       }
+
+    case LOPT_DNSSEC_NTA_FILE:
+      {
+        char* path = opt_string_alloc(arg);
+        struct stat statbuf;
+        if (stat(path, &statbuf) == -1)
+          die(_("cannot access %s: %s"), path, EC_FILE);
+        daemon->nta_file = path;
+        break;
+      }
 #endif
 		
     default:
@@ -4398,6 +4411,7 @@ void read_opts(int argc, char **argv, char *compile_opts)
   daemon->soa_refresh = SOA_REFRESH;
   daemon->soa_retry = SOA_RETRY;
   daemon->soa_expiry = SOA_EXPIRY;
+  daemon->nta_file = NULL;
 
   add_txt("version.bind", "dnsmasq-" VERSION, 0 );
   add_txt("authors.bind", "Simon Kelley", 0);
